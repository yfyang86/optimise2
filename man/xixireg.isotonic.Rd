% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/xixi.R
\name{xixireg.isotonic}
\alias{xixireg.isotonic}
\title{Solve isotonic regression with tie}
\usage{
xixireg.isotonic(x, y, k = 3, nk = 5)
}
\arguments{
\item{x}{on risk total at time 1,...,N}

\item{y}{dealth}

\item{k}{number of clusters}

\item{nk}{number of local cluster to split data}
}
\value{
a numeric vector of jumppoints
}
\description{
\code{xixireg.isotonic} uses max-min algorithm to solve isotonic regression
with C backend. In general, only O(n1/3) jump points will be reported.
}
\examples{
#|                        ________
#|                       ^
#|                      /
#|                    /
#|         ~~~~~~~~~~~
#| ......./
#|/
#|s1------s2---------s3----------s4
n=1e5
M=3
s.real = c(0,.55,.75,1)
ys.real = c(.1,.2,.9,1)
a.real= 1: (M+1)
b.real =  diff(ys.real)/diff(s.real)
a.real = ys.real[1]
for (ii in 2:M){
    a.real[ii] = ys.real[ii] - b.real[ii]*s.real[ii]
}
compute.region <- function(A, bp){
    A <- sort(A)
    b = bp
    for (i in 1:length(bp)){
        b[i]=sum(A<=bp[i])
    }
    return(b);
}
simu.re <- function(y){
    n = length(y)
    epsilon = sort(abs(rnorm(n)/40))
    ys.real = y+epsilon
    # normalize
    ys.real = ys.real - ys.real[1]
    ys.real = ys.real/ys.real[n]
    return(ys.real);
}
y.predf <- function(a,b,s,n,...){
    x = sort(runif(n))
    y = x
    ns = length(s)
    Region <- c(1,compute.region(x,s[-c(1,ns)]),n)
    Region <- data.frame(
        start = Region[1:(ns-1)],
        end = Region[2:ns]
    )
    Region.Label <- 1:n
    for (i in 1:(ns-1)){
        Region.Label[Region[i,1]:Region[i,2]] = i
    }

    for (i in 1:(ns-1)){
        y[Region[i,1]:Region[i,2]] = a[i]+b[i]*x[Region[i,1]:Region[i,2]]
    }

    y = simu.re(y)

    return(
        list(x = x,
             y = y,
             region = Region,
             region.label=Region.Label
        )
    );
}
y.pred <- y.predf(a=a.real, b=b.real, s.real, n)
ss <- sort(sample(n,10000))
plot(y.pred$x[ss],y.pred$y[ss],col=y.pred$region.label[ss],pch='+')
ds=data.frame(x=y.pred$x[ss],y=y.pred$y[ss])
piecewosereg <- function(data,M){
    rpartMethod <- rpart(y~x,data=data)
    ## a is possible break points
    a=unique(as.double(gsub("[ <>=[:alpha:]]",'',labels(rpartMethod))))
    a=a[!is.na(a)]
    ##
    if (length(a)<M) stop("detection failed");
    PossibleNodes <- combn(1:length(a),M) # it is in raising order!
    mm = ncol(PossibleNodes)
    LossfunctionValue = list()
    for(ii in 1:mm){
        breakpoints <- a[PossibleNodes[,ii]]
        cat("\\nDetect Points:\\t",breakpoints,'\\n')
        LossfunctionValue[[ii]] <- segmented(lm(y~x,data),
                                             seg.Z = ~x, psi=breakpoints
        )
    }
    Mini = LossfunctionValue[[which.min(
        unlist(lapply(LossfunctionValue,function(x)summary(x)$sigma))
    )]]


    return(list(rpart.Initial = a, SegDetect = LossfunctionValue, Result = Mini));
}
# use segmented model: slow
# u1 <- piecewosereg(ds,2)
# u1$Result
s.real
y.pred <- y.predf(a=a.real, b=b.real, s.real, n)
ss <- sort(sample(n,10000))
ds=data.frame(x=y.pred$x[ss],y=y.pred$y[ss])
xixireg.isotonic(x = ds$x, y = ds$y, k = 3, nk = 4)
}
\seealso{
\code{\link{isoreg}}.
}

